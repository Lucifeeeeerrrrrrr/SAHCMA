# apply_cpu_governor

Esse script √© um **controlador t√©rmico e sem√¢ntico** de governors da CPU, projetado pra **evitar troca desnecess√°ria, instabilidade, flapping de carga** e outras merdas que podem fazer seu chip rebolar devagarinho. Ele **n√£o troca de governor feito um pamonha**, mas apenas quando a situa√ß√£o realmente pede, e quando troca, o faz com cooldown calculado com base em **temperatura e vari√¢ncia de carga**.

```bash
apply_cpu_governor() {
    local cpu_gov="$1"
    local base_dir="${BASE_DIR:-/tmp}"
    local last_gov_file="${base_dir}/last_gov"
    local cooldown_file="${base_dir}/gov_cooldown"
    local available_govs_file="/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors"
    local now=$(date +%s)

    ## Subfun√ß√£o: Pega temperatura atual do pacote de CPU
    get_temp() {
        local temp_raw
        temp_raw=$(sensors 2>/dev/null | grep -m1 'Package id 0' | awk '{print $4}' | tr -d '+¬∞C')
        echo "${temp_raw:-40}"  # fallback pra 40¬∞C se falhar
    }

    ## Subfun√ß√£o: Pega m√©dia de carga nos √∫ltimos 1, 5 e 15 minutos
    get_loadavg() {
        uptime | awk -F'load average: ' '{print $2}' | awk -F', ' '{print $1, $2, $3}'
    }

    ## Subfun√ß√£o: C√°lculo de vari√¢ncia simples entre 1m e 5m
    get_load_variance() {
        local l1 l5 delta
        read l1 l5 _ < <(get_loadavg)
        delta=$(echo "$l1 - $l5" | bc -l)
        echo "${delta#-}"  # valor absoluto
    }

    ## Subfun√ß√£o: Calcula cooldown com base em varia√ß√£o de carga e temp
    calc_dynamic_cooldown() {
        local delta_load=$(get_load_variance)
        local temp=$(get_temp)
        local cd=7

        # Temperatura acima de 75¬∞C = risco
        if (( temp >= 75 )); then
            cd=$((cd + 5))
        elif (( temp >= 60 )); then
            cd=$((cd + 3))
        fi

        # Oscila√ß√£o de carga alta = sistema inst√°vel
        if (( $(echo "$delta_load > 1.5" | bc -l) )); then
            cd=$((cd + 4))
        elif (( $(echo "$delta_load > 0.8" | bc -l) )); then
            cd=$((cd + 2))
        elif (( $(echo "$delta_load < 0.3" | bc -l) )); then
            cd=$((cd - 2))
        fi

        (( cd < 3 )) && cd=3
        echo "$cd"
    }

    ## Subfun√ß√£o: Valida governor
    is_valid_governor() {
        grep -qw "$1" "$available_govs_file"
    }

    ## Subfun√ß√£o: Aplica governor a todos os CPUs com fallback
    set_governor_all_cpus() {
        local gov="$1"
        for cpu_dir in /sys/devices/system/cpu/cpu[0-9]*; do
            if [[ -w "$cpu_dir/cpufreq/scaling_governor" ]]; then
                echo "$gov" > "$cpu_dir/cpufreq/scaling_governor" || echo "Erro ao aplicar em $cpu_dir"
            fi
        done
    }

    ## Execu√ß√£o principal

    # Valida√ß√£o
    if ! is_valid_governor "$cpu_gov"; then
        echo "‚úñ Governor '$cpu_gov' n√£o √© suportado neste sistema."
        return 1
    fi

    # L√™ √∫ltimo governor
    local last_gov="none"
    [[ -f "$last_gov_file" ]] && last_gov=$(cat "$last_gov_file")

    echo "üéõ Governor: Atual=${last_gov} | Novo=${cpu_gov}"

    # L√≥gica de cooldown 
    local last_change=0
    [[ -f "$cooldown_file" ]] && last_change=$(date -r "$cooldown_file" +%s)
    local delta=$((now - last_change))
    local dynamic_cd=$(calc_dynamic_cooldown)

    if [[ "$cpu_gov" != "$last_gov" && "$delta" -ge "$dynamic_cd" ]]; then
        echo "  üîß Alterando governor... (Cooldown: ${dynamic_cd}s)"
        set_governor_all_cpus "$cpu_gov"
        echo "$cpu_gov" > "$last_gov_file"
        touch "$cooldown_file"
    else
        echo "  ‚è≥ Cooldown ativo (${delta}s/${dynamic_cd}s) ou governor j√° aplicado"
    fi
}

```
---

## Pra que serve essa caralhudo?

Pra impedir que script mal feito, daemon hist√©rico ou humano tapado fiquem jogando governors de um lado pro outro como se fosse ping-pong. Essa fun√ß√£o cria um **mecanismo de conten√ß√£o adaptativa**, armazenando o √∫ltimo estado aplicado e bloqueando altera√ß√µes precipitadas com base em contexto operacional real.

Ele, em paralelo ao corpo, se comporta como o **sistema nervoso aut√¥nomo**:
- Simp√°tico(acelera) = performance
- Parasimp√°tico(freia) = powersave
- Feedback via temperatura, batimentos, respora√ß√£o

---

## Como essa ele funciona?

1. **Persist√™ncia de estado m√≠nima**
   Um arquivo (`last_gov_file`) guarda o √∫ltimo governor aplicado, evitando gastar tempo, I/O e ciclos aplicando o mesmo estado repetidamente.
   > Aqui pretendo usar futuramente como um token para criar um espa√ßo matematico que representa sifnificado.

2. **Cooldown din√¢mico**
   O script calcula o intervalo necess√°rio antes de permitir nova troca sem ficar girando no pr√≥prio rabo trocando governor a cada segundo. Isso aqui considera:

   * **Temperatura da CPU** (acima de 60¬∞C, o tempo de espera sobe)
   * **Instabilidade de carga** (se o load average estiver subindo e descendo igual eletrocardiograma de gente com ataque, a troca espera)
   > Sem esse cooldown, o script se comporta como um macaco hiperativo com crack na veia.

3. **Valida√ß√£o de governor**
   Antes de fazer a mudan√ßa, o script checa se o governor solicitado realmente existe no sistema para evitar jogar lixo no sistema.

4. **Aplica√ß√£o segura pra todos os n√∫cleos**
   Aplica o governor a todos os CPUs dispon√≠veis e de algum estiver offline ou protegido, manda um erro claro e segue com os outros.

5. **Opera√ß√£o baseada em contexto real, n√£o f√© cega**
   Nada √© feito por instinto e tudo depende de c√°lculos simples baseados em temperatura, tempo e carga, sendo **reativo, mas inteligente.**

---

## Diagrama de fluxo l√≥gico (em bom e claro Mermaid)

```mermaid
flowchart TD
    Start([In√≠cio]) --> CheckGovVal{Governor v√°lido?}
    CheckGovVal -- N√£o --> ExitInvalidGov[[Erro: Governor inv√°lido]]
    CheckGovVal -- Sim --> LoadState[Carrega √∫ltimo estado]
    LoadState --> CompareGov{Mudou do anterior?}
    CompareGov -- N√£o --> SkipChange[[Mesma merda. Ignora.]]
    CompareGov -- Sim --> CalcCooldown[Calcula cooldown]
    CalcCooldown --> TimeCheck{Cooldown expirou?}
    TimeCheck -- N√£o --> WaitCooldown[[Aguarda cooldown]]
    TimeCheck -- Sim --> ApplyGov[Aplica governor]
    ApplyGov --> UpdateState[Atualiza estado]
    UpdateState --> End([Fim])
```

---

## Detalhamento t√©cnico

### Vari√¢ncia de carga (`Œîload`)

Calculada como a diferen√ßa absoluta entre `loadavg` de 1 e 5 minutos. Se essa diferen√ßa for muito grande, √© sinal de que o sistema t√° oscilando e **a troca √© adiada**.

### Temperatura da CPU (`Tcpu`)

Obtida com `lm-sensors`, onde se a temperatura estiver batendo nos 75¬∞C, **a troca entra no modo de precau√ß√£o** e evita mudan√ßas

### Cooldown m√≠nimo (`cd_min`)

O cooldown atua como per√≠odo refrat√°rio de um neuronio, onde quando um neur√¥nio dispara, ele entra num estado que **n√£o pode disparar de novo imediatamente**, assim impede loops neurais ou sobrecargas sin√°pticas.

3 segundos pra impedir que um sistema est√°vel fique se enrolando √† toa.

### Penalidades e b√¥nus no cooldown

* `+5s` se temperatura ‚â• 75¬∞C
* `+3s` se temperatura ‚â• 60¬∞C
* `+4s` se Œîload > 1.5
* `+2s` se Œîload > 0.8
* `-2s` se Œîload < 0.3 (se o sistema est√°vel trocar r√°pido)

### Escrita no sysfs

Feita de forma direta com `>` (sem `>>`) pra manter atomicidade e n√£o fazer merda com append para atribui√ß√£o e o estabelecimento de uma sinapse digital minimalista.

O objetivo futuro, al√©m de otimizar a fun√ß√£o, √© definir uma compress√£o entr√≥pica e criar uma memoria de longo prazo atrav√©s de uma LLM de 4k bem leve.



---

## O que esse tro√ßo N√ÉO faz

* N√£o tenta ser daemon, mas pode ser chamado via `cron`, `systemd`, hook de `udev` ou o caralho que quiser.
* N√£o fica olhando logs, hist√≥rico ou astrologia do sistema, e sim funciona com a logica markoviana do **aqui e agora**(pique a sua vis√£o em primeira pessoa).
* N√£o √© plug-and-play pra distros sem `sensors`, `bc` ou permiss√µes root.

---

## Por que essa merda √© melhor que usar `cpupower` direto?

Porque `cpupower frequency-set -g performance` √© burro e **n√£o sabe se j√° t√° em performance**, **n√£o sabe se o sistema t√° fervendo**, **n√£o sabe se a carga acabou de subir do nada**, apenas obedece.

O objetivo √© estar dentro de um campo de hilbert confinado que altera o estado geral do sistema em harmonia com as outras fun√ß√µes, dentro de um micro-hivermind, que √© uma rede local de decis√µes aut√¥nomas interigadas. 
> O todo do projeto √© formado por c√©lulas especializadas, mas que trocam de sinais atrav√©s de uma unica leitura do valor atual de CPU, colapsando para uma configura√ß√£o, onde o Linux simula a relativadade

---

## Requisitos

* Linux com subsistema `cpufreq` ativado
* `lm-sensors` instalado e configurado corretamente
* `bc` pro c√°lculo flutuante
* Permiss√µes de root ou `sudo` pra escrita no sysfs